using Basilisque.CodeAnalysis.Syntax;

namespace Basilisque.CodeAnalysis.Tests.Syntax
{
    [TestClass]
    public class CompilationInfoTests
    {



        private const string C_CODEGENERATION_ATTRIBUTE_STRING_COMPILATION_INFO = @"//------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//   <GeneratorName>, <GeneratorVersion>
//   
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------

";

        private const string C_CODEGENERATION_ATTRIBUTE_STRING_CLASS_INFO = @"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""<GeneratorName>"", ""<GeneratorVersion>"")]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
";

        private const string C_CODEGENERATION_ATTRIBUTE_STRING_CLASS_INFO_INDENTED = @"    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""<GeneratorName>"", ""<GeneratorVersion>"")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
";

        private string _codeGenerationAttributeStringCompilationInfo;
        private string _codeGenerationAttributeStringClassInfo;
        private string _codeGenerationAttributeStringClassInfoIndented;

        public CompilationInfoTests()
        {
            var execAssemblyName = System.Reflection.Assembly.GetExecutingAssembly().GetName();

            _codeGenerationAttributeStringCompilationInfo = C_CODEGENERATION_ATTRIBUTE_STRING_COMPILATION_INFO
                .Replace("<GeneratorName>", execAssemblyName.Name)
                .Replace("<GeneratorVersion>", execAssemblyName.Version?.ToString() ?? "1.0.0.0");

            _codeGenerationAttributeStringClassInfo = C_CODEGENERATION_ATTRIBUTE_STRING_CLASS_INFO
                .Replace("<GeneratorName>", execAssemblyName.Name)
                .Replace("<GeneratorVersion>", execAssemblyName.Version?.ToString() ?? "1.0.0.0");

            _codeGenerationAttributeStringClassInfoIndented = C_CODEGENERATION_ATTRIBUTE_STRING_CLASS_INFO_INDENTED
                .Replace("<GeneratorName>", execAssemblyName.Name)
                .Replace("<GeneratorVersion>", execAssemblyName.Version?.ToString() ?? "1.0.0.0");
        }

        [DataTestMethod]
        [DataRow(null, true, DisplayName = "ns: null - codeGenAttr: true")]
        [DataRow(null, false, DisplayName = "ns: null - codeGenAttr: false")]
        [DataRow("", true, DisplayName = "ns: empty string - codeGenAttr: true")]
        [DataRow("", false, DisplayName = "ns: empty string - codeGenAttr: false")]
        [DataRow("   ", true, DisplayName = "ns: whitespace - codeGenAttr: true")]
        [DataRow("   ", false, DisplayName = "ns: whitespace - codeGenAttr: false")]
        public void NoNamespace_NoClass_IsEmpty(string ns, bool codeGenAttrEnabled)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", targetNamespace: ns);
            compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabled;

            var str = compilationInfo.ToString();

            Assert.AreEqual(string.Empty, str);
        }

        [DataTestMethod]
        [DataRow(true, DisplayName = "nullable context enabled")]
        [DataRow(false, DisplayName = "nullable context disabled")]
        public void NoNamespace_NoClass_IsEmpty_WithNullableContext(bool enableNullableContext)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", targetNamespace: null);
            compilationInfo.EnableNullableContext = enableNullableContext;

            var str = compilationInfo.ToString();

            Assert.AreEqual(string.Empty, str);
        }

        [DataTestMethod]
        [DataRow(null, null, DisplayName = "ns: null - codeGenAttr: <default>")]
        [DataRow(null, true, DisplayName = "ns: null - codeGenAttr: true")]
        [DataRow(null, false, DisplayName = "ns: null - codeGenAttr: false")]
        [DataRow("", null, DisplayName = "ns: empty string - codeGenAttr: <default>")]
        [DataRow("", true, DisplayName = "ns: empty string - codeGenAttr: true")]
        [DataRow("", false, DisplayName = "ns: empty string - codeGenAttr: false")]
        [DataRow("   ", null, DisplayName = "ns: whitespace - codeGenAttr: <default>")]
        [DataRow("   ", true, DisplayName = "ns: whitespace - codeGenAttr: true")]
        [DataRow("   ", false, DisplayName = "ns: whitespace - codeGenAttr: false")]
        public void NoNamespace_1Class_CorrectString(string ns, bool? codeGenAttrEnabled)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", targetNamespace: ns)
                .AddNewClassInfo("MyClass1", AccessModifier.Public, ci =>
                {
                    if (codeGenAttrEnabled.HasValue)
                        ci.AddGeneratedCodeAttributes = codeGenAttrEnabled.Value;
                });

            compilationInfo.EnableNullableContext = false;

            if (codeGenAttrEnabled.HasValue)
                compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabled.Value;

            var str = compilationInfo.ToString();

            string codeGenAttrStr = (!codeGenAttrEnabled.HasValue || (codeGenAttrEnabled.HasValue && codeGenAttrEnabled.Value)) ? _codeGenerationAttributeStringCompilationInfo + _codeGenerationAttributeStringClassInfo : string.Empty;
            Assert.AreEqual(codeGenAttrStr + @"public class MyClass1
{
}", str);
        }

        [DataTestMethod]
        [DataRow(null, DisplayName = "nullable context <default> (enabled)")]
        [DataRow(true, DisplayName = "nullable context enabled")]
        [DataRow(false, DisplayName = "nullable context disabled")]
        public void NoNamespace_1Class_NullableContext_CorrectString(bool? enableNullableContext)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", targetNamespace: null)
                .AddNewClassInfo("MyClass1", AccessModifier.Public, ci => { ci.AddGeneratedCodeAttributes = false; });

            if (enableNullableContext.HasValue)
                compilationInfo.EnableNullableContext = enableNullableContext.Value;

            compilationInfo.AddGeneratedCodeAttributes = false;

            var str = compilationInfo.ToString();

            var expectedResult = @"public class MyClass1
{
}";

            if (!enableNullableContext.HasValue || (enableNullableContext.HasValue && enableNullableContext.Value))
                expectedResult = @"#nullable enable

" + expectedResult + @"

#nullable restore";

            Assert.AreEqual(expectedResult, str);
        }

        [TestMethod]
        [DataRow(true, true, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: true")]
        [DataRow(true, false, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: false")]
        [DataRow(false, true, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: true")]
        [DataRow(false, false, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: false")]
        public void NoNamespace_2Classes_CorrectString(bool codeGenAttrEnabledCompilationInfo, bool codeGenAttrEnabledClassInfo)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", null)
                .AddNewClassInfo("MyClass1", AccessModifier.Public, ci => { ci.AddGeneratedCodeAttributes = codeGenAttrEnabledClassInfo; })
                .AddNewClassInfo("MyClass2", AccessModifier.Public, ci => { ci.AddGeneratedCodeAttributes = codeGenAttrEnabledClassInfo; });

            compilationInfo.EnableNullableContext = false;
            compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabledCompilationInfo;

            var str = compilationInfo.ToString();

            string codeGenAttrStrCompInfo = codeGenAttrEnabledCompilationInfo ? _codeGenerationAttributeStringCompilationInfo : string.Empty;
            string codeGenAttrStrClassInfo = codeGenAttrEnabledClassInfo ? _codeGenerationAttributeStringClassInfo : string.Empty;

            Assert.AreEqual(codeGenAttrStrCompInfo + codeGenAttrStrClassInfo + @"public class MyClass1
{
}

" + codeGenAttrStrClassInfo + @"public class MyClass2
{
}", str);
        }

        [TestMethod]
        [DataRow(true, DisplayName = "codeGenAttr: true")]
        [DataRow(false, DisplayName = "codeGenAttr: false")]
        public void WithNamespace_NoClass_CorrectString(bool codeGenAttrEnabled)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1");

            compilationInfo.EnableNullableContext = false;
            compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabled;

            var str = compilationInfo.ToString();

            string codeGenAttrStr = codeGenAttrEnabled ? _codeGenerationAttributeStringCompilationInfo : string.Empty;

            Assert.AreEqual(codeGenAttrStr + @"namespace MyNamespace1
{
}", str);
        }

        [DataTestMethod]
        [DataRow(null, DisplayName = "nullable context <default> (enabled)")]
        [DataRow(true, DisplayName = "nullable context enabled")]
        [DataRow(false, DisplayName = "nullable context disabled")]
        public void WithNamespace_NoClass_NullableContext_CorrectString(bool? enableNullableContext)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1");

            if (enableNullableContext.HasValue)
                compilationInfo.EnableNullableContext = enableNullableContext.Value;

            compilationInfo.AddGeneratedCodeAttributes = false;

            var str = compilationInfo.ToString();

            var expectedResult = @"namespace MyNamespace1
{
}";

            if (!enableNullableContext.HasValue || (enableNullableContext.HasValue && enableNullableContext.Value))
                expectedResult = @"#nullable enable

" + expectedResult + @"

#nullable restore";

            Assert.AreEqual(expectedResult, str);
        }

        [TestMethod]
        [DataRow(true, true, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: true")]
        [DataRow(true, false, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: false")]
        [DataRow(false, true, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: true")]
        [DataRow(false, false, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: false")]
        public void WithNamespace_1Class_CorrectString(bool codeGenAttrEnabledCompilation, bool codeGenAttrEnabledClass)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1")
                .AddNewClassInfo("MyClass1", AccessModifier.Public, ci => { ci.AddGeneratedCodeAttributes = codeGenAttrEnabledClass; });

            compilationInfo.EnableNullableContext = false;
            compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabledCompilation;

            var str = compilationInfo.ToString();

            string codeGenAttrStrCompilation = codeGenAttrEnabledCompilation ? _codeGenerationAttributeStringCompilationInfo : string.Empty;
            string codeGenAttrStrClass = codeGenAttrEnabledClass ? _codeGenerationAttributeStringClassInfoIndented : string.Empty;

            Assert.AreEqual(codeGenAttrStrCompilation + @"namespace MyNamespace1
{
" + codeGenAttrStrClass + @"    public class MyClass1
    {
    }
}", str);
        }

        [TestMethod]
        [DataRow(true, true, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: true")]
        [DataRow(true, false, DisplayName = "codeGenAttr Compilation: true, codeGenAttr Class: false")]
        [DataRow(false, true, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: true")]
        [DataRow(false, false, DisplayName = "codeGenAttr Compilation: false, codeGenAttr Class: false")]
        public void WithNamespace_2Classes_CorrectString(bool codeGenAttrEnabledCompilation, bool codeGenAttrEnabledClass)
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1")
                .AddNewClassInfo("MyClass1", AccessModifier.Public, ci => { ci.AddGeneratedCodeAttributes = codeGenAttrEnabledClass; })
                .AddNewClassInfo("MyClass2", ci => { ci.AddGeneratedCodeAttributes = codeGenAttrEnabledClass; });

            compilationInfo.EnableNullableContext = false;
            compilationInfo.AddGeneratedCodeAttributes = codeGenAttrEnabledCompilation;

            var str = compilationInfo.ToString();

            string codeGenAttrStrCompilation = codeGenAttrEnabledCompilation ? _codeGenerationAttributeStringCompilationInfo : string.Empty;
            string codeGenAttrStrClass = codeGenAttrEnabledClass ? _codeGenerationAttributeStringClassInfoIndented : string.Empty;

            Assert.AreEqual(codeGenAttrStrCompilation + @"namespace MyNamespace1
{
" + codeGenAttrStrClass + @"    public class MyClass1
    {
    }

" + codeGenAttrStrClass + @"    public class MyClass2
    {
    }
}", str);
        }

        [DataTestMethod]
        [DataRow(null, DisplayName = "null")]
        [DataRow("", DisplayName = "empty string")]
        [DataRow("   ", DisplayName = "whitespace")]
        public void EmptyCompliationName_Throws(string compilationName)
        {
            Assert.ThrowsException<ArgumentNullException>(() => new CompilationInfo(compilationName, null));

            var compilationInfo = new CompilationInfo("Name1", "Namespace1");
            Assert.ThrowsException<ArgumentNullException>(() => compilationInfo.CompilationName = null!);
        }

        [TestMethod]
        public void CompilationName_Property_CorrectValue()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", null);

            Assert.AreEqual("MyInfo4711", compilationInfo.CompilationName);

            compilationInfo.CompilationName = "MyInfo0815";
            Assert.AreEqual("MyInfo0815", compilationInfo.CompilationName);
        }

        [TestMethod]
        public void TargetNamespace_Property_CorrectValue()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", "MyNS1");

            Assert.AreEqual("MyNS1", compilationInfo.TargetNamespace);

            compilationInfo.TargetNamespace = "MyNS2";
            Assert.AreEqual("MyNS2", compilationInfo.TargetNamespace);

            compilationInfo.TargetNamespace = null;
            Assert.AreEqual(null, compilationInfo.TargetNamespace);
        }

        [TestMethod]
        public void GeneratedCodeToolName_Property_CorrectValue()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", "MyNS1", "MyToolName1", "MyToolVersion1");

            Assert.AreEqual("MyToolName1", compilationInfo.GeneratedCodeToolName);

            compilationInfo.GeneratedCodeToolName = "MyToolName2";
            Assert.AreEqual("MyToolName2", compilationInfo.GeneratedCodeToolName);
        }

        [TestMethod]
        public void GeneratedCodeToolVersion_Property_CorrectValue()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", "MyNS1", "MyToolName1", "MyToolVersion1");

            Assert.AreEqual("MyToolVersion1", compilationInfo.GeneratedCodeToolVersion);

            compilationInfo.GeneratedCodeToolVersion = "MyToolVersion2";
            Assert.AreEqual("MyToolVersion2", compilationInfo.GeneratedCodeToolVersion);
        }

        [TestMethod]
        public void ToStringWithStringBuilder_ThrowsWhenStringBuilderIsNull()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", "MyNS1");

            Assert.ThrowsException<ArgumentNullException>(() => compilationInfo.ToString(null!, 0, Language.CSharp));
        }

        [TestMethod]
        public void ToStringWithStringBuilder_ThrowsWhenIndentationCountIsLessThanZero()
        {
            var compilationInfo = new CompilationInfo("MyInfo4711", "MyNS1");

            var sb = new System.Text.StringBuilder();

            Assert.ThrowsException<ArgumentOutOfRangeException>(() => compilationInfo.ToString(sb, -1, Language.CSharp));
        }

        [TestMethod]
        public void CodeGenerationAttribute_SetOnOneOfTwoClasses()
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1")
                .AddNewClassInfo("MyClass1", AccessModifier.ProtectedInternal, ci => { ci.AddGeneratedCodeAttributes = false; })
                .AddNewClassInfo("MyClass2", ci => { ci.AddGeneratedCodeAttributes = true; });

            compilationInfo.EnableNullableContext = false;

            var str = compilationInfo.ToString();

            Assert.AreEqual(_codeGenerationAttributeStringCompilationInfo + @"namespace MyNamespace1
{
    protected internal class MyClass1
    {
    }

" + _codeGenerationAttributeStringClassInfoIndented + @"    public class MyClass2
    {
    }
}", str);
        }

        [TestMethod]
        public void CodeGenerationAttribute_ToolNameAndVersion_CanBeSpecifiedWithConstructor()
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1", "MyGenToolName", "MyGenToolVersion1");

            compilationInfo.EnableNullableContext = false;

            var str = compilationInfo.ToString();

            Assert.AreEqual(C_CODEGENERATION_ATTRIBUTE_STRING_COMPILATION_INFO.Replace("<GeneratorName>", "MyGenToolName").Replace("<GeneratorVersion>", "MyGenToolVersion1") + @"namespace MyNamespace1
{
}", str);
        }

        [TestMethod]
        public void CodeGenerationAttribute_ToolNameAndVersion_CanBeSpecifiedWithConstructor_ForInnerClass()
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", null, "MyGenToolName", "MyGenToolVersion1");

            compilationInfo.EnableNullableContext = false;

            compilationInfo.AddNewClassInfo("MyClass1", ci => { });

            var str = compilationInfo.ToString();

            Assert.AreEqual(C_CODEGENERATION_ATTRIBUTE_STRING_COMPILATION_INFO.Replace("<GeneratorName>", "MyGenToolName").Replace("<GeneratorVersion>", "MyGenToolVersion1") + C_CODEGENERATION_ATTRIBUTE_STRING_CLASS_INFO.Replace("<GeneratorName>", "MyGenToolName").Replace("<GeneratorVersion>", "MyGenToolVersion1") + @"public class MyClass1
{
}", str);
        }

        [DataTestMethod]
        [DataRow("MyCompilation1", "MyCompilation1.g.cs", Language.CSharp, DisplayName = "name without extension")]
        [DataRow("MyCompilation1.g", "MyCompilation1.g.cs", Language.CSharp, DisplayName = "name with .g extension")]
        [DataRow("MyCompilation1.g.cs", "MyCompilation1.g.cs", Language.CSharp, DisplayName = "name with .g.cs extension")]
        [DataRow("MyCompilation1.cs", "MyCompilation1.cs", Language.CSharp, DisplayName = "name with .cs extension")]
        [DataRow("MyCompilation1.my.cs", "MyCompilation1.my.cs", Language.CSharp, DisplayName = "name with .my.cs extension")]
        [DataRow("MyCompilation1", "MyCompilation1.g.cs", -1, DisplayName = "Invalid language defaults to C#")]
        [DataRow("MyCompilation1", "MyCompilation1.g.vb", Language.VisualBasic, DisplayName = "VB language without extension")]
        [DataRow("MyCompilation1.g.cs", "MyCompilation1.g.cs.g.vb", Language.VisualBasic, DisplayName = "Invalid extension is ignored")]
        public void GetHintName_ReturnsCorrectName(string compilationName, string expectedResult, Language language)
        {
            var compilationInfo = new CompilationInfo(compilationName, "MyNamespace1");

            var hintName = compilationInfo.GetHintName(language);

            Assert.AreEqual(expectedResult, hintName);
        }

        [TestMethod]
        public void ToString_ForVisualBasic_ThrowsNotSupportedException()
        {
            var compilationInfo = new CompilationInfo("MyCompilation1", "MyNamespace1");

            Assert.ThrowsException<NotSupportedException>(() => compilationInfo.ToString(Language.VisualBasic));
        }
    }
}
